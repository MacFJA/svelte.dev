---
title: Warnings d'exécution
---

## Warnings client [!VO]Client warnings

<!-- This file is generated by scripts/process-messages/index.js. Do not edit! -->

### assignment_value_stale

```
Assignment to `%property%` property (%location%) will evaluate to the right-hand side, not the value of `%property%` following the assignment. This may result in unexpected behaviour.
```

Étant donné le cas suivant...

```svelte
<script>
	let object = $state({ array: null });

	function add() {
		(object.array ??= []).push(object.array.length);
	}
</script>

<button onclick={add}>ajouter</button>
<p>éléments : {JSON.stringify(object.items)}</p>
```

... le tableau dans lequel on ajoute des éléments lorsque le bouton est cliqué pour la première fois
est le `[]` à droite de l'assignation, mais la valeur résultante de `object.array` est un proxy
d'état vide. En conséquence, la valeur ajoutée est ignorée.

Vous pouvez corriger cela en séparant le code en deux morceaux :

```js
let object = { array: [0] };
// ---cut---
function add() {
	object.array ??= [];
	object.array.push(object.array.length);
}
```

### binding_property_non_reactive

```
`%binding%` is binding to a non-reactive property
```

```
`%binding%` (%location%) is binding to a non-reactive property
```

### console_log_state

```
Your `console.%method%` contained `$state` proxies. Consider using `$inspect(...)` or `$state.snapshot(...)` instead
```

Lorsque vous loggez un
[proxy](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Proxy), les
outils développeur du navigateur vont logger le proxy lui-même plutôt que la valeur qu'il
représente. Dans le cas de Svelte, la "cible" d'un proxy de `$state` peut ne pas ressembler à sa
valeur courante, ce qui peut prêter à confusion.

La manière la plus simple de logger une valeur lorsqu'elle évolue est d'utiliser la rune
[`$inspect`](https://svelte.dev/docs/svelte/$inspect). Autrement, si vous souhaitez logger des
choses une seule fois (par exemple au sein d'un gestionnaire d'évènement), vous pouvez utiliser
[`$state.snapshot`](https://svelte.dev/docs/svelte/$state#$state.snapshot) pour prendre un
instantané de la valeur courante.

### event_handler_invalid

```
%handler% should be a function. Did you mean to %suggestion%?
```

### hydration_attribute_changed

```
The `%attribute%` attribute on `%html%` changed its value between server and client renders. The client value, `%value%`, will be ignored in favour of the server value
```

### hydration_html_changed

```
The value of an `{@html ...}` block changed between server and client renders. The client value will be ignored in favour of the server value
```

```
The value of an `{@html ...}` block %location% changed between server and client renders. The client value will be ignored in favour of the server value
```

### hydration_mismatch

```
Hydration failed because the initial UI does not match what was rendered on the server
```

```
Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near %location%
```

### invalid_raw_snippet_render

```
The `render` function passed to `createRawSnippet` should return HTML for a single element
```

### legacy_recursive_reactive_block

```
Detected a migrated `$:` reactive block in `%filename%` that both accesses and updates the same reactive value. This may cause recursive updates when converted to an `$effect`.
```

### lifecycle_double_unmount

```
Tried to unmount a component that was not mounted
```

### ownership_invalid_binding

```
%parent% passed a value to %child% with `bind:`, but the value is owned by %owner%. Consider creating a binding between %owner% and %parent%
```

### ownership_invalid_mutation

```
Mutating a value outside the component that created it is strongly discouraged. Consider passing values to child components with `bind:`, or use a callback instead
```

```
%component% mutated a value owned by %owner%. This is strongly discouraged. Consider passing values to child components with `bind:`, or use a callback instead
```

### reactive_declaration_non_reactive_property

```
A `$:` statement (%location%) read reactive state that was not visible to the compiler. Updates to this state will not cause the statement to re-run. The behaviour of this code will change if you migrate it to runes mode
```

En mode legacy, une [déclaration
réactive](https://svelte.dev/docs/svelte/legacy-reactive-assignments) avec `$:` est rejouée lorsque
l'état qu'elle _référence_ change. Ceci est déterminé au moment de la compilation, en analysant le
code.

En mode runes, les effects et les dérivations sont rejouées lorsqu'il y a des changements dans les
valeurs qui sont lues pendant l'_exécution_ de la fonction.

Souvent, le résultat est le même dans les deux cas – par exemple ces deux écritures peuvent être
considérées comme équivalentes :

```js
let a = 1, b = 2, sum = 3;
// ---cut---
$: sum = a + b;
```

```js
let a = 1, b = 2;
// ---cut---
const sum = $derived(a + b);
```

Dans certains cas – comme celui qui déclenche le warning ci-dessus – elles ne sont _pas_
équivalentes :

```js
let a = 1, b = 2, sum = 3;
// ---cut---
const add = () => a + b;

// le compilateur ne peut "voir" que `sum` dépend de `a` et `b`, mais
// elles seront bien lues pendant l'exécution de la version `$derived`
$: sum = add();
```

De même, les propriétés réactives d'un [état
profond](https://svelte.dev/docs/svelte/$state#Deep-state) ne sont pas visibles par le compilateur.
Ainsi, les changements affectant ces propriétés vont déclencher la ré-exécution des effets et les
dérivations, mais _pas_ celle des déclarations `$:`.

Lorsque vous [migrerez ce composant](https://svelte.dev/docs/svelte/v5-migration-guide) en mode runes,
le comportement sera celui décrit ici.

### state_proxy_equality_mismatch

```
Reactive `$state(...)` proxies and the values they proxy have different identities. Because of this, comparisons with `%operator%` will produce unexpected results
```

`$state(...)` crée un
[proxy](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Proxy) de la
valeur fournie. Le proxy est la valeur ont des identités différentes, ce qui implique que les
vérifications d'égalité donneront toujours `false` :

```svelte
<script>
	let value = { foo: 'bar' };
	let proxy = $state(value);

	value === proxy; // toujours false
</script>
```

Pour contourner ce problème, assurez-vous de toujours comparer des valeurs qui ont soit toutes les
deux été créées avec `$state(...)`, soit toutes les deux pas. Notez que `$state.raw(...)` ne va
_pas_ créer de proxy d'état.

## Warnings client et serveur [!VO]Shared warnings

<!-- This file is generated by scripts/process-messages/index.js. Do not edit! -->

### dynamic_void_element_content

```
`<svelte:element this="%tag%">` is a void element — it cannot have content
```

### state_snapshot_uncloneable

```
Value cannot be cloned with `$state.snapshot` — the original value was returned
```

```
The following properties cannot be cloned with `$state.snapshot` — the return value contains the originals:

%properties%
```

